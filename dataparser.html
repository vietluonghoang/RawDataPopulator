<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document Parser</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    textarea {
      width: 100%;
      height: 200px;
      margin-bottom: 10px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    table, th, td {
      border: 1px solid black;
    }
    th, td {
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #f2f2f2;
    }
    #resultTable td {
      white-space: pre-wrap;
      vertical-align: top;
    }
    .parse-button {
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: bold;
    }

    .parse-button:disabled {
        cursor: not-allowed;
    }

    .parse-button.empty {
        background-color: #ff5252;
        color: white;
    }

    .parse-button.ready {
        background-color: #4caf50;
        color: white;
    }

    .parse-button.parsing {
        background-color: #ffd700;
        color: #2e7d32;
    }
  </style>
</head>
<body>
  <h2>Document Parser</h2>
  <label for="rawInput">Paste the plain text document below:</label>
  <textarea id="rawInput" placeholder="Paste your document here..."></textarea>
  <button id="parseButton" class="parse-button empty" onclick="parseDocument()" disabled>Fill the input</button>

  <h3>Parsed Structure</h3>
  <table id="resultTable">
    <thead>
      <tr>
        <th>ID</th>
        <th>Name</th>
        <th>Title</th>
        <th>Detail</th>
        <th>Parent ID</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    // Get references to the elements
    const inputArea = document.getElementById('rawInput');
    const parseButton = document.getElementById('parseButton');

    // Add input listener to check content
    inputArea.addEventListener('input', function() {
        if (this.value.trim() === '') {
            parseButton.disabled = true;
            parseButton.textContent = 'Fill the input';
            parseButton.className = 'parse-button empty';
        } else {
            parseButton.disabled = false;
            parseButton.textContent = 'Parse Document';
            parseButton.className = 'parse-button ready';
        }
    });

    // Add these before the parseDocument function
    const levelPatterns = [
        { name: 'Phần', regex: /^(Phần(?: thứ)? [^\n]+?)\s*(.*)/iu },
        { name: 'Phụ lục', regex: /^(Phụ lục [^\n]+?)\s*(.*)/iu },
        { name: 'Chương', regex: /^(Chương\s+(?:[IVX]+|\d+))\s*(.*)/iu },
        { name: 'Mục', regex: /^(Mục [^\n]+?)\s*(.*)/iu },
        { name: 'Điều', regex: /^(Điều [^\n]+?\.)\s*(.*)/iu },
        { name: 'NumberDot', regex: /^(\d+\.)\s*(.*)/iu },
        { name: 'CharDotOrParen', regex: /^([\p{L}]\.|[\p{L}]\))\s*(.*)/iu }
    ];

    function findLevel(line) {
        for (const level of levelPatterns) {
            const match = line.match(level.regex);
            if (match) {
                return { 
                    name: level.name, 
                    fullMatch: match[1].trim(),
                    title: match[2].trim()
                };
            }
        }
        return null;
    }

    function isChildLevel(parentName, childName) {
        const levelHierarchy = [
            'Phần',
            'Phụ lục',
            'Chương',
            'Mục',
            'Điều',
            'NumberDot',
            'CharDotOrParen'
        ];
        return levelHierarchy.indexOf(childName) > levelHierarchy.indexOf(parentName);
    }

    // Modify the parseDocument function to include button states
    async function parseDocument() {
        // Set parsing state
        parseButton.disabled = true;
        parseButton.textContent = 'Parsing...';
        parseButton.className = 'parse-button parsing';

        try {
            // Clear the table first
            const tableBody = document.querySelector('#resultTable tbody');
            tableBody.innerHTML = '';

            const rawText = document.getElementById('rawInput').value;
            const lines = rawText.split(/\n/);
            const levels = [];
            let idCounter = 0;
            let parentStack = [];
            let currentDetail = '';
            let pendingTitle = null;
            let emptyLineCount = 0;

            lines.forEach((line, index) => {
                const trimmed = line.trim();
                
                if (!trimmed) {
                    emptyLineCount++;
                    if (currentDetail && emptyLineCount === 1) {
                        currentDetail = currentDetail.trimEnd() + '\\n\\n';
                    }
                    return;
                }
                emptyLineCount = 0;

                const levelMatch = findLevel(trimmed);
                if (levelMatch) {
                    const id = ++idCounter;
                    
                    if (currentDetail) {
                        levels[levels.length - 1].detail = currentDetail.trimEnd();
                        currentDetail = '';
                    }

                    while (
                        parentStack.length > 0 &&
                        !isChildLevel(parentStack[parentStack.length - 1].name, levelMatch.name)
                    ) {
                        parentStack.pop();
                    }
                    const parentId = parentStack.length > 0 ? parentStack[parentStack.length - 1].id : null;

                    if (!levelMatch.title) {
                        pendingTitle = levelMatch.name;
                        levels.push({ 
                            id, 
                            name: levelMatch.fullMatch,
                            title: '',
                            detail: '',
                            parentId 
                        });
                    } else {
                        pendingTitle = null;
                        levels.push({ 
                            id, 
                            name: levelMatch.fullMatch,
                            title: levelMatch.title,
                            detail: '',
                            parentId 
                        });
                    }

                    parentStack.push({ id, name: levelMatch.name });
                } else {
                    if (pendingTitle && levels.length > 0) {
                        levels[levels.length - 1].title = trimmed;
                        pendingTitle = null;
                    } else {
                        const lastLevel = levels[levels.length - 1];
                        if (lastLevel && trimmed !== lastLevel.title) {
                            if (currentDetail) {
                                if (currentDetail.endsWith('\\n\\n')) {
                                    currentDetail += trimmed;
                                } else {
                                    currentDetail = currentDetail.trimEnd() + '\\n' + trimmed;
                                }
                            } else {
                                currentDetail = trimmed;
                            }
                        }
                    }
                }
            });

            // Handle any remaining detail
            if (currentDetail && levels.length > 0) {
                levels[levels.length - 1].detail = currentDetail.trimEnd();
            }

            // Populate the table
            levels.forEach(level => {
                const row = document.createElement('tr');
                
                // Create and populate cells
                [level.id, level.name, level.title, level.detail, level.parentId || ''].forEach(text => {
                    const cell = document.createElement('td');
                    cell.textContent = text;
                    row.appendChild(cell);
                });
                
                tableBody.appendChild(row);
            });
        } finally {
            // Reset button state after parsing (whether successful or not)
            parseButton.disabled = false;
            parseButton.textContent = 'Parse Document';
            parseButton.className = 'parse-button ready';
        }
    }
  </script>
</body>
</html>
